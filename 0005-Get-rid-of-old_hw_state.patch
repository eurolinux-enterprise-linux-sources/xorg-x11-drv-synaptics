From 2f9c49aeee5963c381e8d145583f3326fd7fe4df Mon Sep 17 00:00:00 2001
From: Hans de Goede <hdegoede@redhat.com>
Date: Fri, 21 Feb 2014 10:31:40 +0100
Subject: [PATCH synaptics 05/14] Get rid of old_hw_state

We only use it to store button state which we already have in
priv->lastButtons.

While at it also properly indent the code block checking the various
soft button areas.

Signed-off-by: Hans de Goede <hdegoede@redhat.com>
Signed-off-by: Peter Hutterer <peter.hutterer@who-t.net>
(cherry picked from commit effeee86c1c286cd09ab750efc4932790dd560dd)
(cherry picked from commit f712eb7c41436c3f84a0d244be879c5c118788c5)

Conflicts:
	src/synaptics.c

Conflict result from 1bd4ca3b5af6e5ee98c7d7f153fd4ee643c29e1a
   Revert "Purge scrollbuttons (repeat)"
in upstream 1.7 branch but not here
---
 src/synaptics.c    | 58 ++++++++++++++++++++++--------------------------------
 src/synapticsstr.h |  1 -
 2 files changed, 23 insertions(+), 36 deletions(-)

diff --git a/src/synaptics.c b/src/synaptics.c
index 7ba8b0f..5a2c160 100644
--- a/src/synaptics.c
+++ b/src/synaptics.c
@@ -1003,7 +1003,6 @@ SynapticsReset(SynapticsPrivate * priv)
 {
     SynapticsResetHwState(priv->hwState);
     SynapticsResetHwState(priv->local_hw_state);
-    SynapticsResetHwState(priv->old_hw_state);
     SynapticsResetHwState(priv->comm.hwState);
 
     memset(priv->move_hist, 0, sizeof(priv->move_hist));
@@ -1072,7 +1071,6 @@ DeviceClose(DeviceIntPtr dev)
     free(priv->touch_axes);
     priv->touch_axes = NULL;
     SynapticsHwStateFree(&priv->hwState);
-    SynapticsHwStateFree(&priv->old_hw_state);
     SynapticsHwStateFree(&priv->local_hw_state);
     SynapticsHwStateFree(&priv->comm.hwState);
     return RetValue;
@@ -1318,10 +1316,6 @@ DeviceInit(DeviceIntPtr dev)
     if (!priv->hwState)
         goto fail;
 
-    priv->old_hw_state = SynapticsHwStateAlloc(priv);
-    if (!priv->old_hw_state)
-        goto fail;
-
     priv->local_hw_state = SynapticsHwStateAlloc(priv);
     if (!priv->local_hw_state)
         goto fail;
@@ -2596,7 +2590,7 @@ handle_clickfinger(SynapticsPrivate * priv, struct SynapticsHwState *hw)
 
 static void
 update_hw_button_state(const InputInfoPtr pInfo, struct SynapticsHwState *hw,
-                       struct SynapticsHwState *old, CARD32 now, int *delay)
+                       CARD32 now, int *delay)
 {
     SynapticsPrivate *priv = (SynapticsPrivate *) (pInfo->private);
     SynapticsParameters *para = &priv->synpara;
@@ -2612,39 +2606,36 @@ update_hw_button_state(const InputInfoPtr pInfo, struct SynapticsHwState *hw,
      * the soft button instead. */
     if (para->clickpad) {
         /* hw->left is down, but no other buttons were already down */
-        if (!old->left && !old->right && !old->middle &&
-            hw->left && !hw->right && !hw->middle) {
-                if (is_inside_rightbutton_area(para, hw->x, hw->y)) {
-                    hw->left = 0;
-                    hw->right = 1;
-                }
-                else if (is_inside_sec_rightbutton_area(para, hw->x, hw->y)) {
-                    hw->left = 0;
-                    hw->right = 1;
-                }
-                else if (is_inside_middlebutton_area(para, hw->x, hw->y)) {
-                    hw->left = 0;
-                    hw->middle = 1;
-                }
-                else if (is_inside_sec_middlebutton_area(para, hw->x, hw->y)) {
-                    hw->left = 0;
-                    hw->middle = 1;
-                }
+        if (!(priv->lastButtons & 7) && hw->left && !hw->right && !hw->middle) {
+            if (is_inside_rightbutton_area(para, hw->x, hw->y)) {
+                hw->left = 0;
+                hw->right = 1;
+            }
+            else if (is_inside_sec_rightbutton_area(para, hw->x, hw->y)) {
+                hw->left = 0;
+                hw->right = 1;
+            }
+            else if (is_inside_middlebutton_area(para, hw->x, hw->y)) {
+                hw->left = 0;
+                hw->middle = 1;
+            }
+            else if (is_inside_sec_middlebutton_area(para, hw->x, hw->y)) {
+                hw->left = 0;
+                hw->middle = 1;
+            }
         }
         else if (hw->left) {
-            hw->left = old->left;
-            hw->right = old->right;
-            hw->middle = old->middle;
+            hw->left   = (priv->lastButtons & 1) ? 1 : 0;
+            hw->middle = (priv->lastButtons & 2) ? 1 : 0;
+            hw->right  = (priv->lastButtons & 4) ? 1 : 0;
         }
     }
 
     /* Fingers emulate other buttons. ClickFinger can only be
        triggered on transition, when left is pressed
      */
-    if (hw->left && !old->left && !old->middle && !old->right &&
-        hw->numFingers >= 1) {
+    if (hw->left && !(priv->lastButtons & 7) && hw->numFingers >= 1)
         handle_clickfinger(priv, hw);
-    }
 
     /* Two finger emulation */
     if (hw->numFingers == 1 && hw->z >= para->emulate_twofinger_z &&
@@ -2876,7 +2867,7 @@ HandleState(InputInfoPtr pInfo, struct SynapticsHwState *hw, CARD32 now,
     inside_active_area = is_inside_active_area(priv, hw->x, hw->y);
 
     /* these two just update hw->left, right, etc. */
-    update_hw_button_state(pInfo, hw, priv->old_hw_state, now, &delay);
+    update_hw_button_state(pInfo, hw, now, &delay);
 
     /* now we know that these _coordinates_ aren't in the area.
        invalid are: x, y, z, numFingers, fingerWidth
@@ -2988,9 +2979,6 @@ HandleState(InputInfoPtr pInfo, struct SynapticsHwState *hw, CARD32 now,
     if (inside_active_area)
         store_history(priv, hw->x, hw->y, hw->millis);
 
-    /* Save logical state for transition comparisons */
-    SynapticsCopyHwState(priv->old_hw_state, hw);
-
     return delay;
 }
 
diff --git a/src/synapticsstr.h b/src/synapticsstr.h
index ead54d4..a028b20 100644
--- a/src/synapticsstr.h
+++ b/src/synapticsstr.h
@@ -205,7 +205,6 @@ struct _SynapticsPrivateRec {
     void *proto_data;           /* protocol-specific data */
 
     struct SynapticsHwState *hwState;
-    struct SynapticsHwState *old_hw_state;      /* previous logical hw state */
 
     const char *device;         /* device node */
     CARD32 timer_time;          /* when timer last fired */
-- 
1.9.3

